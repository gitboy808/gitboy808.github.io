<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GitHub搜索技巧</title>
    <url>/2021/06/17/GitHub%E6%89%BE%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="怎么在GitHub上靠谱的找一些开源项目"><a href="#怎么在GitHub上靠谱的找一些开源项目" class="headerlink" title="怎么在GitHub上靠谱的找一些开源项目"></a>怎么在GitHub上靠谱的找一些开源项目</h2><ul>
<li>按照项目名称/仓库名搜索（大小写敏感）</li>
</ul>
<p>in:name xxx</p>
<ul>
<li>按照README搜索（大小写敏感）</li>
</ul>
<p>in:readme xxx</p>
<ul>
<li>按照description搜索（大小写敏感）</li>
</ul>
<p>in:description xxx</p>
<ul>
<li>stars数大于xxx</li>
</ul>
<p>stars:&gt;xxx</p>
<ul>
<li>forks数大于xxx</li>
</ul>
<p>forks:&gt;xxx</p>
<ul>
<li>编程语言为xxx</li>
</ul>
<p>language:xxx</p>
<ul>
<li>最新更新时间晚于yyyy–mm–dd</li>
</ul>
<p>pushed:&gt;yyyy–mm–dd</p>
]]></content>
      <categories>
        <category>方法类</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>butterfly配置分页</title>
    <url>/2021/06/22/butterfly%E9%85%8D%E7%BD%AE%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<h2 id="配置分页"><a href="#配置分页" class="headerlink" title="配置分页"></a>配置分页</h2><p>title:【必需】页面标题<br>date:【必需】页面创建日期<br>type: 【必需】标籤、分类和友情链接三个页面需要配置<br>updated:【可选】页面更新日期<br>tags:</p>
<ul>
<li>…<br>categories:</li>
<li>…<br>description:【可选】页面描述<br>keywords: 【可选】页面关键字<br>comments: 【可选】显示页面评论模块 (默认 true)<br>top_img: 【可选】页面顶部图片<br>mathjax: 【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)<br>katex: 【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false)<br>aside: 【可选】显示侧边栏 (默认 true)<br>aplayer: 【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置<br>highlight_shrink: 【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)</li>
</ul>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>title:【必需】页面标题<br>date:【必需】页面创建日期<br>tags:</p>
<ul>
<li>…<br>categories:</li>
<li>…<br>description:【可选】页面描述<br>keywords: 【可选】页面关键字<br>top_img: 【可选】页面顶部图片</li>
</ul>
]]></content>
      <categories>
        <category>方法类</category>
      </categories>
      <tags>
        <tag>butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/06/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is my very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>markdown笔记</title>
    <url>/2021/06/10/md%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><h2 id="形式二级标题"><a href="#形式二级标题" class="headerlink" title="-形式二级标题"></a>-形式二级标题</h2><h2 id="使用-号可表示1-6级标题"><a href="#使用-号可表示1-6级标题" class="headerlink" title="使用#号可表示1-6级标题"></a>使用#号可表示1-6级标题</h2><h1 id="段落格式"><a href="#段落格式" class="headerlink" title="段落格式"></a>段落格式</h1><p>段落换行是使用两个以上空格加上回车</p>
<p>第一行文字内容<br>第二行文字内容</p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>Markdown可以使用以下几种字体：</p>
<p><em>斜体文字</em><br><em>斜体文字</em><br><strong>粗体文字</strong><br><strong>粗体文字</strong><br><em><strong>粗斜体文字</strong></em><br><em><strong>粗斜体文字</strong></em></p>
<h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>可以使用三个以上的 ’ * ‘ 号来建立一个分隔线</p>
<hr>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>在需要加删除线的文本两端加上~~即可</p>
<p><del>文本</del></p>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>下划线可以通过HTML的<u>标签来实现：</p>
<p><u>带下划线的文本</u></p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>脚注是对文本的补充说明。<br>MarkDown脚注的格式如下：</p>
<p>[^要注明的文本]</p>
<p>以下示例演示脚注的用法：<br>创建注释脚注格式类似这样[^RUN]。</p>
<p>[^RUN]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表使用（*）、（+）或是(-)作为 列表标记，这些标记后面要添加一个空格，然后再填写内容：</p>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表使用数字加上 . 号来表示，比如：</p>
<p>1.第一项<br>2.第二项<br>3.第三项</p>
<h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>列表嵌套只需要在列表中的选项前面添加四个空格即可：</p>
<p>1.第一项:<br>    + 第一项嵌套的第一个元素<br>    + 第一项嵌套的第二个元素<br>2.第二项:<br>    * 第二项嵌套的第一个元素<br>    * 第二项嵌套的第二个元素</p>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>Markdown区块引用是在段落开头使用 &gt; 符号，然后后面紧跟一个空格符号：</p>
<blockquote>
<p>区块引用<br>菜鸟教程<br>学的不仅是技术更是梦想</p>
</blockquote>
<p>另外区块是可以嵌套的，一个 &gt; 两个 &gt; 符号是第一层嵌套，以此类推：</p>
<blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h3><p>如果要在列表项目中内放进区块，那么就需要在&gt;前添加四个空格的缩进。</p>
<ul>
<li>第一项<blockquote>
<p>菜鸟教程<br>学的不仅是技术更是梦想</p>
</blockquote>
</li>
<li>第二项</li>
</ul>
<hr>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来(`)，例如</p>
<blockquote>
<p><code>printf()</code> 函数</p>
</blockquote>
<h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>代码区块使用<strong>4空格</strong>或者一个<strong>制表符（Tab健）</strong>。</p>
<pre><code>&lt;?php
echo &#39;RUNOOB&#39;;
function test()&#123;
    echo &#39;test&#39;;
&#125;
</code></pre>
<p>你也可以使用 ``` 包裹一段代码,并指定一种语言（也可以不指定）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(doucment).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;RUNOOB&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接使用方法如下：</p>
<blockquote>
<p><a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接名称</a><br>或者</p>
<p>&lt;链接地址&gt;</p>
</blockquote>
<h3 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h3><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p>
<blockquote>
<p>这个链接用 1 作为网址变量 <a href="http://static.runoob.com/images/runoob-logo.png" title="菜鸟教程png">Google</a><br>这个链接用 runoob 作为网址变量 [Runoob][runoob]<br>然后在文档的结尾为变量赋值(网址)</p>
<pre><code>[1]: http://www.google.com/
</code></pre>
</blockquote>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>Markdown 图片语法格式如下：</p>
<blockquote>
<p><img src="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本"><br><img src="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本" title="可选标题"></p>
</blockquote>
<ul>
<li>开头一个感叹号！</li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面方案上图片的网址，最后还可以用引号包上并加上选择性的”title”属性的文字。</li>
</ul>
<p>使用示例：</p>
<blockquote>
<p><img src="http://static.com/images/runoob-logo.png" alt="RUNOOB 图标"><br><img src="http://static.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"></p>
</blockquote>
<p>当然，你也可以像网址那样对图片网址使用变量：</p>
<blockquote>
<p>这个链接用 1 作为网址变量<a href="http://static.runoob.com/images/runoob-logo.png" title="菜鸟教程png">RUNOOB</a>.<br>然后在这个文档的结尾为变量赋值(网址)</p>
</blockquote>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>Markdown 表格使用<code>|</code>来分隔不同的单元格，使用<code>-</code>来分隔表头和其他行。<br>语法格式如下：</p>
<blockquote>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
</blockquote>
<p>对齐方式：<br><strong>我们可以设置表格的对齐方式：</strong></p>
<ul>
<li><code>-:</code> 设置内容和标题栏右对齐</li>
<li><code>:-</code> 设置内容和标题栏左对齐</li>
<li><code>:-:</code> 设置内容和标题栏居中对齐</li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
</blockquote>
]]></content>
      <categories>
        <category>技能类</category>
      </categories>
      <tags>
        <tag>md</tag>
      </tags>
  </entry>
  <entry>
    <title>资源</title>
    <url>/2021/06/22/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><h3 id="idea的激活方式"><a href="#idea的激活方式" class="headerlink" title="idea的激活方式"></a>idea的激活方式</h3><p>需要环境： idea</p>
<hr>
<p>1.获取激活码打开 <a href="http://vrg123.com/">网址</a>（需要关注公众号获取）<br>2.复制激活码，打开idea：help -&gt; Register… -&gt; add new…<br>3.恭喜你永久免费了</p>
<h2 id="聚合网站"><a href="#聚合网站" class="headerlink" title="聚合网站"></a>聚合网站</h2><h3 id="资源导航网站"><a href="#资源导航网站" class="headerlink" title="资源导航网站"></a>资源导航网站</h3><p>1.电子书资源网站导航 <a href="http://shuxiangjia.cn/">书享家</a><br>2.自学资源网站导航 <a href="https://www.xue8nav.com/">学吧导航</a><br>3.学术资源网站导航 <a href="https://site.sciping.com/">科塔学术</a><br>4.PPT资源网站导航 <a href="http://www.hippter.com/">HiPPTer</a><br>5.设计素材资源导航 <a href="https://www.seeseed.com/">Seeseed</a></p>
<h3 id="工具导航网站"><a href="#工具导航网站" class="headerlink" title="工具导航网站"></a>工具导航网站</h3><p>1.互联网工具导航<a href="https://dh.woshipm.com/">阿猫阿狗导航</a><br>2.互联网工具导航<a href="http://chuangzaoshi.com/index">创造狮</a><br>3.数据导航<a href="http://hao.199it.com/">199it</a><br>4.财经工具导航<a href="https://xueqiu.com/dh">雪球导航</a></p>
<h3 id="聚合搜索平台"><a href="#聚合搜索平台" class="headerlink" title="聚合搜索平台"></a>聚合搜索平台</h3><ul>
<li>一个开始<a href="https://aur.one/">go</a></li>
<li>虫部落<a href="https://search.chongbuluo.com/">go</a></li>
</ul>
<h2 id="网站推荐"><a href="#网站推荐" class="headerlink" title="网站推荐"></a>网站推荐</h2><h3 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h3><ul>
<li><a href="https://pixabay.com/zh/">pixabay</a></li>
<li><a href="https://unsplash.com/">Unsplash</a></li>
<li><a href="https://www.pexels.com/zh-cn/">Pexels</a></li>
<li><a href="https://www.foodiesfeed.com/">Foodiesfeed </a></li>
<li><a href="https://cc0.cn/">CC零图片网</a></li>
<li><a href="https://www.logosc.cn/so/">Logo神器</a></li>
</ul>
<h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><ul>
<li><a href="https://www.iconfont.cn/">iconfont</a></li>
<li><a href="https://iconstore.co/">iconstore</a></li>
<li><a href="https://undraw.co/illustrations">unDraw</a></li>
<li><a href="https://www.iconfinder.com/">ICONFINDER</a></li>
<li><a href="https://icons8.com/">ICONS8</a></li>
</ul>
<h3 id="矢量图、免抠PNG、PSD模板"><a href="#矢量图、免抠PNG、PSD模板" class="headerlink" title="矢量图、免抠PNG、PSD模板"></a>矢量图、免抠PNG、PSD模板</h3><ul>
<li><a href="https://www.freepik.com/">freepik</a></li>
<li><a href="https://free-psd-templates.com/">free-PSD-templates</a></li>
<li><a href="https://365psd.com/">365psd</a></li>
<li><a href="http://pngimg.com/">pngimage</a></li>
<li><a href="https://www.cleanpng.com/">CLEANPNG</a></li>
</ul>
<h3 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h3><ul>
<li><a href="https://wallhaven.cc/">wallhaven</a></li>
<li><a href="https://wall.alphacoders.com/">Wallpaper Abyss</a></li>
<li><a href="https://bz.zzzmh.cn/">极简壁纸</a></li>
</ul>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><ul>
<li><a href="https://www.videezy.com/">Videezy </a></li>
<li><a href="https://www.videvo.net/">Videvo</a></li>
<li><a href="https://mixkit.co/">mixkit</a></li>
<li><a href="https://wedistill.io/">distill</a></li>
</ul>
<h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><ul>
<li><a href="https://audionautix.com/">audionautix </a></li>
<li><a href="https://freepd.com/">Freepd</a></li>
<li><a href="https://freesound.org/">Freesound</a></li>
<li><a href="https://www.ear0.com/">耳聆网</a></li>
<li><a href="https://www.tosound.com/">淘声网</a></li>
</ul>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul>
<li><a href="https://www.hellofont.cn/">字由</a></li>
<li><a href="https://www.100font.com/">100font</a></li>
</ul>
<h3 id="PPT模板"><a href="#PPT模板" class="headerlink" title="PPT模板"></a>PPT模板</h3><ul>
<li><a href="http://www.officeplus.cn/Template/Home.shtml">OfficePLUS</a></li>
<li><a href="http://ppt.sotary.com/web/wxapp/index.html">PPT超级市场</a></li>
<li><a href="http://www.51pptmoban.com/ppt/">51PPT模板</a></li>
<li><a href="https://www.ppthui.com/">PPT汇</a></li>
<li><a href="http://www.ypppt.com/">优品PPT</a></li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1.二次元整合网站 <a href="https://moe321.com/">二次元</a><br>2.可攻可受的发送接收？ <a href="https://airportal.cn/">攻受</a><br>3.P站 <a href="https://pixivic.com/">P站</a><br>4.万能音乐下载<a href="http://www.guqiankun.com/">GO</a><br>5.<a href="https://www.mvcat.com/">电影推荐</a><br>6.<a href="https://www.secaibi.com/tools/">图片压缩小工具</a><br>7.全球网络工具程度<a href="https://cybermap.kaspersky.com/">装逼</a></p>
]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>激活</tag>
        <tag>工具</tag>
        <tag>网站推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>git指南</title>
    <url>/2021/06/22/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><h3 id="windows上安装"><a href="#windows上安装" class="headerlink" title="windows上安装"></a>windows上安装</h3><p>在windows上使用Git，可以哦那个从<a href="https://pc.qq.com/">腾讯软件中心</a> 搜索git下载安装即可。<br>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！<br>安装完成后，还需要最后一步设置，在命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意: git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p>
<p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>

<p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>
<hr>
<p>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p>
<p>现在我们编写一个<code>readme.txt</code>文件，内容如下：</p>
<pre><code>Git is a version control system.
Git is free software.
</code></pre>
<p>把一个文件放到GIt仓库只需要两步：</p>
<p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>

<p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p>
<p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;wrote a readme file&quot;</span></span><br><span class="line">[master (root-commit) b028f87] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure>

<p>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m <span class="string">&quot;add 3 files.&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h2><h3 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h3><p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：</p>
<pre><code>Git is a distributed version control system.
Git is free software.
</code></pre>
<p>现在，运行<code>git status</code>命令看看结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        file3.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p>
<p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用<code>git diff</code>这个命令看看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure>

<p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p>
<p>知道了对<code>readme.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>

<p>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure>

<p><code>git status</code>告诉我们，将要被提交的修改包括<code>readme.txt</code>，下一步，就可以放心地提交了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;add distributed&quot;</span></span><br></pre></td></tr></table></figure>

<p>提交后，我们再用git status命令看看仓库的当前状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong><br>要随时掌握工作区的状态，使用<code>git status</code>命令。</p>
<p>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<p>然后尝试提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m <span class="string">&quot;append GPL&quot;</span></span><br><span class="line">[master 1094adb] append GPL</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></table></figure>

<p>需要友情提示的是，你看到的一大串类似<code>bc16...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>
<p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，怎么做呢？</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>bc16...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p>
<p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本add distributed，就可以使用<code>git reset</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 12e2856 add distributed</span><br></pre></td></tr></table></figure>

<p>最新的那个版本已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个版本的<code>commit id</code>是<code>1dcfe2e1...</code>，于是就可以指定回到未来的某个版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 1dcfe</span><br><span class="line">HEAD is now at 1dcfe21 append GPL</span><br></pre></td></tr></table></figure>

<p>你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>ppend GPL</code>，就必须找到<code>append GPL的commit id</code>。Git提供了一个命令git reflog用来记录你的每一次命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">1dcfe21 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 1dcfe</span><br><span class="line">12e2856 HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1dcfe21 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">12e2856 HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">bd496e3 HEAD@&#123;4&#125;: commit: add 3 files.</span><br><span class="line">b028f87 HEAD@&#123;5&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure>

<p><strong>总结一下</strong></p>
<p><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</p>
<p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p>
<p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>案例一、在你准备提交前可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure>

<p>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure>

<p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<p>案例二、假设<code>git add</code>到暂存区了：</p>
<p>庆幸的是，在commit之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交，Git同样告诉我们用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       readme.txt</span><br></pre></td></tr></table></figure>

<p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。<br>再用git status查看一下，现在暂存区是干净的，工作区有修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>还记得如何丢弃工作区的修改吗？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>案例三、假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得<code>版本回退</code>一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把<code>提交</code>推送到远程版本库，你就真的惨了……</p>
<p><strong>小结</strong></p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<code>版本回退</code>一节，不过前提是没有推送到远程库。</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add test.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;add test.txt&quot;</span></span><br><span class="line">[master f3254e3] add test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br></pre></td></tr></table></figure>

<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm test.txt</span><br></pre></td></tr></table></figure>

<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm <span class="string">&#x27;test.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;remove test.txt&quot;</span></span><br><span class="line">[master 999e31d] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure>

<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure>

<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p>
<p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<pre><code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;
</code></pre>
<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是<code>SSH Key</code>的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>
<p>第2步：登陆GitHub，打开“settings”，“SSH Keys”页面：</p>
<p>然后，点“New SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p>
<h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>
<p>首先，登陆GitHub，然后，在右上角找到“New repository”按钮，创建一个新的仓库：</p>
<p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p>
<p>目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p>现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:name/learngit.git</span><br></pre></td></tr></table></figure>

<p>请千万注意，把上面的<code>name</code>替换成你自己的GitHub账户名，添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p>
<p>显示所有远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:gitboy808/newGit.git (fetch)</span><br><span class="line">origin  git@github.com:gitboy808/newGit.git (push)</span><br></pre></td></tr></table></figure>

<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Enumerating objects: 18, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (18/18), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (13/13), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (18/18), 1.40 KiB | 479.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 18 (delta 4), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">To github.com:gitboy808/newGit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch <span class="string">&#x27;master&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;master&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p>
<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：</p>
<p>从现在起，只要本地作了提交，就可以通过命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p>
<h3 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h3><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p>
<p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p>
<h3 id="删除远程库"><a href="#删除远程库" class="headerlink" title="删除远程库"></a>删除远程库</h3><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm name</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p>
<p>然后，根据名字删除，比如删除<code>origin</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote rm origin</span><br></pre></td></tr></table></figure>

<p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p>
<p><strong>小结</strong></p>
<p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p>
<p>关联一个远程库时必须给远程库指定一个名字，<code>origin</code>是默认习惯命名；</p>
<p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>
<h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p>
<p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>
<p>首先，登陆GitHub，创建一个新的仓库，名字叫<code>gitskills</code>：</p>
<p>我们勾选<code>Add a README file</code>，这样GitHub会自动为我们创建一个<code>README.md</code>文件。创建完毕后，可以看到<code>README.md</code>文件：</p>
<p>本机git仓库并没有和这个SSH key 关联上。用下述方法解决：</p>
<pre><code>ssh-add &quot;你的 id-rsa 文件地址&quot;
</code></pre>
<p>注意这里ssh-add后面填的是私钥地址</p>
<p>现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:name/gitskills.git</span><br></pre></td></tr></table></figure>

<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p>
<p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p>
<h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>首先，我们创建dev分支，然后切换到dev分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure>

<p>然后，用<code>git branch</code>命令查看当前分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>

<p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>✳</code>号。</p>
<p>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：</p>
<pre><code>Creating a new branch is quick.
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">&quot;branch test&quot;</span></span><br><span class="line">[dev 83e65f3] branch <span class="built_in">test</span></span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is up to date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变</p>
<p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating 999e31d..83e65f3</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>readme.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p>
<p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“cat快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p>
<p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p>
<p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was 83e65f3).</span><br></pre></td></tr></table></figure>

<p>删除后，查看branch，就只剩下master分支了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p><strong>switch</strong><br>我们注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。</p>
<p>实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p>
<p>创建并切换到新的dev分支，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git switch -c dev</span><br><span class="line">Switched to a new branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure>

<p>直接切换到已有的master分支，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 1 commit.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br></pre></td></tr></table></figure>

<p>使用新的<code>git switch</code>命令，比<code>git checkout</code>要更容易理解。</p>
<p><strong>小结</strong><br>Git鼓励大量使用分支：</p>
<p>查看分支：<code>git branch</code></p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;或者git switch &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>
<p>准备新的feature1分支，继续我们的新分支开发：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git switch -c feature1</span><br><span class="line">Switched to a new branch <span class="string">&#x27;feature1&#x27;</span></span><br></pre></td></tr></table></figure>

<p>修改<code>readme.txt</code>最后一行，改为：</p>
<pre><code>Creating a new branch is quick AND simple.
</code></pre>
<p>在<code>feature1</code>分支上提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;AND simple&quot;</span></span><br><span class="line">[feature1 3e686be] AND simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>切换到<code>master</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is up to date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p>
<pre><code>Creating a new branch is quick &amp; simple.
</code></pre>
<p>提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;&amp; simple&quot;</span></span><br><span class="line">[master e5f5078] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>
<p>果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。</p>
<p>我们可以直接查看readme.txt的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">Creating a new branch is quick &amp; simple.</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">Creating a new branch is quick AND simple.</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span></span><br></pre></td></tr></table></figure>

<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p>
<pre><code>Creating a new branch is quick and simple.
</code></pre>
<p>再提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;conflict fixed&quot;</span></span><br><span class="line">[master b42e2d9] conflict fixed</span><br></pre></td></tr></table></figure>

<p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   b42e2d9 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\</span><br><span class="line">| * 3e686be (feature1) AND simple</span><br><span class="line">* | e5f5078 &amp; simple</span><br><span class="line">|/</span><br><span class="line">* 83e65f3 (origin/master, dev) branch <span class="built_in">test</span></span><br><span class="line">* 999e31d remove test.txt</span><br><span class="line">* f3254e3 add test.txt</span><br><span class="line">* 1dcfe21 append GPL</span><br><span class="line">* 12e2856 add distributed</span><br><span class="line">* bd496e3 add 3 files.</span><br><span class="line">* b028f87 wrote a readme file</span><br></pre></td></tr></table></figure>

<p>最后，删除<code>feature1</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d feature1</span><br><span class="line">Deleted branch feature1 (was 3e686be).</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p>
<p>首先，仍然创建并切换<code>dev</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git switch -c dev</span><br></pre></td></tr></table></figure>

<p>修改readme.txt文件，并提交一个新的commit：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;add merge&quot;</span></span><br><span class="line">[dev b19c801] add merge</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>现在，我们切换回master：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 3 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br></pre></td></tr></table></figure>

<p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">&quot;merge with no-ff&quot;</span> dev</span><br><span class="line">Merge made by the <span class="string">&#x27;recursive&#x27;</span> strategy.</span><br><span class="line"> readme.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</p>
<p>合并后，我们用git log看看分支历史：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure>

<p><strong>分支策略</strong><br>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p>
<h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        hello.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br></pre></td></tr></table></figure>

<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>
<p>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: dfb65fd add merge</span><br></pre></td></tr></table></figure>

<p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>
<p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 9 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch <span class="string">&#x27;issue-101&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;fix bug 101&quot;</span></span><br><span class="line">[issue-101 a171014] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 9 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m <span class="string">&quot;merged bug fix 101&quot;</span> issue-101</span><br><span class="line">Merge made by the <span class="string">&#x27;recursive&#x27;</span> strategy.</span><br><span class="line"> readme.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到<code>dev</code>分支干活了！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git switch dev</span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: dfb65fd add merge</span><br></pre></td></tr></table></figure>

<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>删除；</p>
<p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        new file:   hello.txt</span><br><span class="line"></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (85b6c7ec84014b1b523ae4b6d486d2b22056a552)</span><br></pre></td></tr></table></figure>

<p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure>

<p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>

<p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。</p>
<p>那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？</p>
<p>有木有更简单的方法？</p>
<p>同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。</p>
<p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  issue-101</span><br><span class="line">  master</span><br><span class="line"></span><br><span class="line">$ git cherry-pick a171014125f</span><br><span class="line">[dev 8079d59] fix bug 101</span><br><span class="line"> Date: Thu Jul 1 16:59:58 2021 +0800</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p>
<p><strong>小结</strong></p>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；</p>
<p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p>
<p>要查看远程库的信息，用<code>git remote</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>

<p>或者，用<code>git remote -v</code>显示更详细的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:gitboy808/newGit.git (fetch)</span><br><span class="line">origin  git@github.com:gitboy808/newGit.git (push)</span><br></pre></td></tr></table></figure>

<p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p>
<h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>如果要推送其他分支，比如<code>dev</code>，就改成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure>

<p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>
<p><code>master</code>分支是主分支，因此要时刻与远程同步；</p>
<p><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
<p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>
<p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
<p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p>
<h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p>
<p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure>

<p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure>

<p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;add env&quot;</span></span><br><span class="line">[dev 32ec948] add env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Enumerating objects: 4, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 278 bytes | 278.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (1/1), completed with 1 <span class="built_in">local</span> object.</span><br><span class="line">To github.com:gitboy808/newGit.git</span><br><span class="line">   c70becb..32ec948  dev -&gt; dev</span><br></pre></td></tr></table></figure>

<p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat env.txt</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;add new env&quot;</span></span><br><span class="line">[dev 89d8311] add new env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">To github.com:gitboy808/newGit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (fetch first)</span><br><span class="line">error: failed to push some refs to <span class="string">&#x27;github.com:gitboy808/newGit.git&#x27;</span></span><br><span class="line">hint: Updates were rejected because the remote contains work that you <span class="keyword">do</span></span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., <span class="string">&#x27;git pull ...&#x27;</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">&#x27;Note about fast-forwards&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;git push --help&#x27;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>

<p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Enumerating objects: 4, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), 258 bytes | 18.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">From github.com:gitboy808/newGit</span><br><span class="line">   c70becb..32ec948  dev        -&gt; origin/dev</span><br><span class="line">There is no tracking information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify <span class="built_in">which</span> branch you want to merge with.</span><br><span class="line">See git-pull(1) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to <span class="built_in">set</span> tracking information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure>

<p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch <span class="string">&#x27;dev&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;dev&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>再pull：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">CONFLICT (add/add): Merge conflict <span class="keyword">in</span> env.txt</span><br><span class="line">Auto-merging env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>

<p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;fix env conflict&quot;</span></span><br><span class="line">[dev 0042b3f] fix env conflict</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Enumerating objects: 9, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (9/9), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 536 bytes | 536.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 2), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (2/2), completed with 1 <span class="built_in">local</span> object.</span><br><span class="line">To github.com:gitboy808/newGit.git</span><br><span class="line">   32ec948..0042b3f  dev -&gt; dev</span><br></pre></td></tr></table></figure>

<p>因此，多人协作的工作模式通常是这样：</p>
<p>1.首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p>
<p>2.如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p>
<p>3.如果合并有冲突，则解决冲突，并在本地提交；</p>
<p>4.没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p>
<p>5.如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<p><strong>小结</strong></p>
<p>查看远程库信息，使用<code>git remote -v</code>；</p>
<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
<p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</p>
<p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p>
<p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p>
<p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p>
<h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p>
<p>每次合并再push后，分支变成了这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   0042b3f (HEAD -&gt; dev, origin/dev) fix env conflict</span><br><span class="line">|\</span><br><span class="line">| * 32ec948 add env</span><br><span class="line">* | 89d8311 add new env</span><br><span class="line">|/</span><br><span class="line">*   c70becb merged feature-vulcan</span><br><span class="line">|\</span><br><span class="line">| * a2c4a15 add feature vulcan</span><br><span class="line">|/</span><br><span class="line">* 8079d59 fix bug 101</span><br><span class="line">* b1f19f3 add hello.txt</span><br></pre></td></tr></table></figure>

<p>总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？</p>
<p>其实是可以做到的！</p>
<p>Git有一种称为rebase的操作，有人把它翻译成“变基”。</p>
<p>在和远程分支同步后，我们对<code>hello.py</code>这个文件做了两次提交。用<code>git log</code>命令看看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* f8d56dc (HEAD -&gt; dev) add authoor</span><br><span class="line">* 02f19fc add comment</span><br><span class="line">*   0042b3f (origin/dev) fix env conflict</span><br><span class="line">|\</span><br><span class="line">| * 32ec948 add env</span><br><span class="line">* | 89d8311 add new env</span><br><span class="line">|/</span><br><span class="line">*   c70becb merged feature-vulcan</span><br><span class="line">|\</span><br><span class="line">| * a2c4a15 add feature vulcan</span><br><span class="line">|/</span><br><span class="line">* 8079d59 fix bug 101</span><br></pre></td></tr></table></figure>

<p>注意到Git用<code>(HEAD -&gt; master)</code>和<code>(origin/master)</code>标识出当前分支的HEAD和远程origin的位置分别是<code>f8d56dc add authoor</code>和<code>0042b3f fix env conflict</code>，本地分支比远程分支快两个提交。</p>
<p>现在我们尝试推送本地分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure>

<p>loading…</p>
<hr>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>
<hr>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line"></span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 16 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br></pre></td></tr></table></figure>

<p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure>

<p>可以用命令<code>git tag</code>查看所有标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure>

<p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>
<p>方法是找到历史提交的commit id，然后打上就可以了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline --abbrev-commit</span><br><span class="line">ae16d0f (HEAD -&gt; master, tag: v1.0) Merge branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">c70becb merged feature-vulcan</span><br><span class="line">a2c4a15 add feature vulcan</span><br><span class="line">8079d59 fix bug 101</span><br><span class="line">b1f19f3 add hello.txt</span><br><span class="line">1d96993 merged bug fix 101</span><br><span class="line">a171014 fix bug 101</span><br><span class="line">8c2d345 merge with no-ff</span><br><span class="line">dfb65fd add merge</span><br><span class="line">d00aab5 aaa</span><br><span class="line">c6fcf64 add - merge</span><br><span class="line">bd49dab change</span><br><span class="line">b19c801 add merge</span><br><span class="line">b42e2d9 conflict fixed</span><br><span class="line">e5f5078 &amp; simple</span><br><span class="line">3e686be AND simple</span><br><span class="line">83e65f3 (origin/master) branch <span class="built_in">test</span></span><br><span class="line">999e31d remove test.txt</span><br></pre></td></tr></table></figure>

<p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>1d96993</code>，敲入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag v0.9 1d96993</span><br></pre></td></tr></table></figure>

<p>再用命令<code>git tag</code>查看标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure>

<p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit 1d9699307c4575a7ce3cf4d9d83fe229c0b49a06 (tag: v0.9)</span><br><span class="line">Merge: 8c2d345 a171014</span><br><span class="line">Author: zhuang &lt;156053994@qq.com&gt;</span><br><span class="line">Date:   Thu Jul 1 17:00:53 2021 +0800</span><br><span class="line"></span><br><span class="line">    merged bug fix 101</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p>
<p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -a v0.1 -m <span class="string">&quot;version 0.1 released&quot;</span> b19c801</span><br></pre></td></tr></table></figure>

<p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git show v0.1</span><br><span class="line">tag v0.1</span><br><span class="line">Tagger: zhuang &lt;156053994@qq.com&gt;</span><br><span class="line">Date:   Thu Jul 1 22:04:04 2021 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line"></span><br><span class="line">commit b19c801b5897c1b59ed69e592b5301da5ded6828 (tag: v0.1)</span><br><span class="line">Author: zhuang &lt;156053994@qq.com&gt;</span><br><span class="line">Date:   Thu Jul 1 12:21:53 2021 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 67ecd2f..ba44501 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> Git is a distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Creating a new branch is quick.</span><br><span class="line">+add merge</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong><br>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p>
<p>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</p>
<p>命令<code>git tag</code>可以查看所有标签。</p>
<h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>如果标签打错了，也可以删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br><span class="line">Deleted tag <span class="string">&#x27;v0.1&#x27;</span> (was eb6f257)</span><br></pre></td></tr></table></figure>

<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Enumerating objects: 8, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (8/8), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (5/5), 684 bytes | 684.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 5 (delta 2), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (2/2), completed with 1 <span class="built_in">local</span> object.</span><br><span class="line">To github.com:gitboy808/newGit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure>

<p>或者，一次性推送全部尚未推送到远程的本地标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To github.com:gitboy808/newGit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure>

<p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag <span class="string">&#x27;v0.9&#x27;</span> (was 1d96993)</span><br></pre></td></tr></table></figure>

<p>然后，从远程删除。删除命令也是push，但是格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To github.com:gitboy808/newGit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure>

<p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p>
<p><strong>小结</strong><br>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</p>
<p>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</p>
<p>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</p>
<p>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</p>
<h3 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h3><p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap">bootstrap</a>，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:gitboy808/bootstrap.git</span><br></pre></td></tr></table></figure>

<p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<code>git@github.com:twbs/bootstrap.git</code>克隆，因为没有权限，你将不能推送修改。</p>
<p>Bootstrap的官方仓库<code>twbs/bootstrap</code>、你在GitHub上克隆的仓库<code>my/bootstrap</code></p>
<p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p>
<p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p>
<h3 id="使用Gitee"><a href="#使用Gitee" class="headerlink" title="使用Gitee"></a>使用Gitee</h3><p>使用Gitee和使用GitHub类似，我们在Gitee上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“设置”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的<code>.ssh/id_rsa.pub</code>文件的内容粘贴进去：</p>
<p>创建ssh密匙</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;git@gitboy808.com&quot;
</code></pre>
<p>如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到Gitee的远程库上呢？</p>
<p>首先，我们在Gitee上创建一个新的项目，选择右上角用户头像 -&gt; 菜单“+”，然后点击“新建仓库”：</p>
<p>然后，我们在本地库上使用命令<code>git remote add</code>把它和Gitee的远程库关联：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure>

<p>之后，就可以正常地用<code>git push</code>和<code>git pull</code>推送了！</p>
<p>如果在使用命令<code>git remote add</code>时报错：</p>
<pre><code>git remote add origin git@gitee.com:liaoxuefeng/learngit.git
fatal: remote origin already exists.
</code></pre>
<p>这说明本地库已经关联了一个名叫<code>origin</code>的远程库，此时，可以先用<code>git remote -v</code>查看远程库信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:gitboy808/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:gitboy808/learngit.git (push)</span><br></pre></td></tr></table></figure>

<p>可以看到，本地库已经关联了<code>origin</code>的远程库，并且，该远程库指向GitHub。</p>
<p>我们可以删除已有的GitHub远程库：</p>
<pre><code>git remote rm origin
</code></pre>
<p>再关联Gitee的远程库（注意路径中需要填写正确的用户名）：</p>
<pre><code>git remote add origin git@gitee.com:gitboy808/learngit.git
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@gitee.com:gitboy808/learngit.git (fetch)</span><br><span class="line">origin  git@gitee.com:gitboy808/learngit.git (push)</span><br></pre></td></tr></table></figure>

<p>现在可以看到，origin已经被关联到Gitee的远程库了。通过<code>git push</code>命令就可以把本地库推送到Gitee上。</p>
<p>有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联Gitee呢？</p>
<p>答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p>
<p>使用多个远程库时，我们要注意，git给远程库起的默认名称是<code>origin</code>，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p>
<p>仍然以<code>learngit</code>本地库为例，我们先删除已关联的名为<code>origin</code>的远程库：</p>
<pre><code>git remote rm origin
</code></pre>
<p>然后，先关联GitHub的远程库：</p>
<pre><code>git remote add github git@github.com:gitboy808/learngit.git
</code></pre>
<p>注意，远程库的名称叫<code>github</code>，不叫<code>origin</code>了。</p>
<p>接着，再关联Gitee的远程库：</p>
<pre><code>git remote add gitee git@gitee.com:gitboy808/learngit.git
</code></pre>
<p>现在，我们用git remote -v查看远程库信息，可以看到两个远程库：</p>
<pre><code>git remote -v
gitee    git@gitee.com:gitboy808/learngit.git (fetch)
gitee    git@gitee.com:gitboy808/learngit.git (push)
github    git@github.com:gitboy808/learngit.git (fetch)
github    git@github.com:gitboy808/learngit.git (push)
</code></pre>
<p>如果要推送到GitHub，使用命令：</p>
<pre><code>git push github master
</code></pre>
<p>如果要推送到Gitee，使用命令：</p>
<pre><code>git push gitee master
</code></pre>
<h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><p>在安装Git一节中，我们已经配置了<code>user.name</code>和<code>user.email</code>，实际上，Git还有很多可配置项。</p>
<p>比如，让Git显示颜色，会让命令输出看起来更醒目：</p>
<pre><code>$ git config --global color.ui true
</code></pre>
<p>这样，Git会适当地显示不同的颜色，比如<code>git status</code>命令：</p>
<p>文件名就会标上颜色。</p>
<h3 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h3><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次<code>git status</code>都会显示<code>Untracked files ...</code>，有强迫症的童鞋心里肯定不爽。</p>
<p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore">gitignore</a></p>
<p>忽略文件的原则是：</p>
<p>1.忽略操作系统自动生成的文件，比如缩略图等；<br>2.忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；<br>3.忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</p>
<p>举个例子：</p>
<p>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件：</p>
<pre><code># Windows:
Thumbs.db
ehthumbs.db
Desktop.ini
</code></pre>
<p>然后，继续忽略Python编译产生的<code>.pyc、.pyo、dist</code>等文件或目录：</p>
<pre><code># Python:
*.py[cod]
*.so
*.egg
*.egg-info
dist
build
</code></pre>
<p>最后一步就是把<code>.gitignore</code>也提交到Git，就完成了！当然检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code>。</p>
<p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了：</p>
<pre><code>$ git add App.class
The following paths are ignored by one of your .gitignore files:
App.class
Use -f if you really want to add them.
</code></pre>
<p>如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git：</p>
<pre><code>$ git add -f App.class
</code></pre>
<p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p>
<pre><code>$ git check-ignore -v App.class
.gitignore:3:*.class    App.class
</code></pre>
<p>Git会告诉我们，<code>.gitignore</code>的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p>
<p>还有些时候，当我们编写了规则排除了部分文件时：</p>
<pre><code># 排除所有.开头的隐藏文件:
.*
# 排除所有.class文件:
*.class
</code></pre>
<p>但是我们发现<code>.*</code>这个规则把<code>.gitignore</code>也排除了，并且<code>App.class</code>需要被添加到版本库，但是被<code>*.class</code>规则排除了。</p>
<p>虽然可以用<code>git add -f</code>强制添加进去，但有强迫症的童鞋还是希望不要破坏<code>.gitignore</code>规则，这个时候，可以添加两条例外规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 排除所有.开头的隐藏文件:</span></span><br><span class="line">.*</span><br><span class="line"><span class="comment"># 排除所有.class文件:</span></span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不排除.gitignore和App.class:</span></span><br><span class="line">!.gitignore</span><br><span class="line">!App.class</span><br></pre></td></tr></table></figure>
<p>把指定文件排除在<code>.gitignore</code>规则外的写法就是<code>!</code>+文件名，所以，只需把例外文件添加进去即可。</p>
<p>loading…</p>
<hr>
<h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>有没有经常敲错命令？比如<code>git status</code>？<code>status</code>这个单词真心不好记。</p>
<p>如果敲<code>git st</code>就表示<code>git status</code>那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p>
<p>我们只需要敲一行命令，告诉Git，以后<code>st</code>就表示<code>status</code>：</p>
<pre><code>$ git config --global alias.st status
</code></pre>
<p>好了，现在敲<code>git st</code>看看效果。</p>
<p>当然还有别的命令可以简写，很多人都用<code>co</code>表示<code>checkout</code>，<code>ci</code>表示<code>commit</code>，<code>br</code>表示<code>branch</code>：</p>
<pre><code>$ git config --global alias.co checkout
$ git config --global alias.ci commit
$ git config --global alias.br branch
</code></pre>
<p>以后提交就可以简写成：</p>
<pre><code>$ git ci -m &quot;bala bala bala...&quot;
</code></pre>
<p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p>
<p>在撤销修改一节中，我们知道，命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个<code>unstage</code>操作，就可以配置一个unstage别名：</p>
<pre><code>$ git config --global alias.unstage &#39;reset HEAD&#39;
</code></pre>
<p>当你敲入命令：</p>
<pre><code>$ git unstage test.py
</code></pre>
<p>实际上Git执行的是：</p>
<pre><code>$ git reset HEAD test.py
</code></pre>
<p>配置一个<code>git last</code>，让其显示最后一次提交信息：</p>
<pre><code>$ git config --global alias.last &#39;log -1&#39;
</code></pre>
<p>这样，用<code>git last</code>就能显示最近一次的提交：</p>
<pre><code>$ git last
</code></pre>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>
<p>配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p>
<pre><code>$ cat .git/config 
</code></pre>
<p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p>
<p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p>
<pre><code>$ cat .gitconfig
</code></pre>
<p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>
<p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的<code>apt</code>命令就可以完成安装。</p>
<p>假设你已经有<code>sudo</code>权限的用户账号，下面，正式开始安装。</p>
<p>第一步，安装<code>git</code>：</p>
<pre><code>$ sudo apt-get install git
</code></pre>
<p>第二步，创建一个<code>git</code>用户，用来运行<code>git</code>服务：</p>
<pre><code>$ sudo adduser git
</code></pre>
<p>第三步，创建证书登录：</p>
<p>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p>
<p>第四步，初始化Git仓库：</p>
<p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在<code>/srv</code>目录下输入命令：</p>
<pre><code>$ sudo git init --bare sample.git
</code></pre>
<p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以<code>.git</code>结尾。然后，把owner改为<code>git</code>：</p>
<pre><code>$ sudo chown -R git:git sample.git
</code></pre>
<p>第五步，禁用shell登录：</p>
<p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑<code>/etc/passwd</code>文件完成。找到类似下面的一行：</p>
<pre><code>git:x:1001:1001:,,,:/home/git:/bin/bash
</code></pre>
<p>改为：</p>
<pre><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell
</code></pre>
<p>这样，<code>git</code>用户可以正常通过ssh使用git，但无法登录shell，因为我们为<code>git</code>用户指定的<code>git-shell</code>每次一登录就自动退出。</p>
<p>第六步，克隆远程仓库：</p>
<p>现在，可以通过<code>git clone</code>命令克隆远程仓库了，在各自的电脑上运行：</p>
<pre><code>$ git clone git@server:/srv/sample.git
Cloning into &#39;sample&#39;...
warning: You appear to have cloned an empty repository.
</code></pre>
<p>剩下的推送就简单了。</p>
<p><strong>小结</strong></p>
<p>搭建Git服务器非常简单，通常10分钟即可完成；</p>
<p>要方便管理公钥，用Gitosis；</p>
<p>要像SVN那样变态地控制权限，用Gitolite。</p>
<h3 id="期末总结"><a href="#期末总结" class="headerlink" title="期末总结"></a>期末总结</h3><p><a href="https://liaoxuefeng.gitee.io/resource.liaoxuefeng.com/git/git-cheat-sheet.pdf">Git Cheat Sheet</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
